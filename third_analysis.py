# -*- coding: utf-8 -*-
"""third_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iWGHxPG-AI0DKavamnJzf8k7EnAKPudq

#  **Desafio House Rocket**
 
A ideia do desafio é poder comprar casas com preço baixo e fazer a revenda com os preços mais altos.
 
Assim, encontrar bons negócios dentro do portfólio disponível, ou seja, encontrar casas com preço mais baixo, em ótimas localizações e que tenham um ótimo potencial de revenda por um preço mais alto.
"""

from google.colab import drive
drive.mount('/content/drive')

# ---------------------------------------
# Libraries
# ---------------------------------------
import pandas as pd
pd.set_option('display.float_format', lambda x: '%.2f' % x)
import numpy as np
from geopy.geocoders import Nominatim
import plotly.express as px

# ---------------------------------------
# Functions
# ---------------------------------------
def show_dtypes(data):
  return print(data.dtypes, end='\n')

def show_dimensions(data):
  # data dimensions
  print('\nNumber of rows: {}'.format(data.shape[0]))
  print('Number of columns: {}'.format(data.shape[1]), end='\n')
  return None

def collect_geodata(data, cols):
  geolocator = Nominatim(user_agent = 'geopiExercices')
  data = data.head(20)

  for i in cols:
    data[cols[0]] = np.NaN
    data[cols[1]] = np.NaN

  for i in range(data.shape[0]):
    query = str(data.loc[i, 'lat']) + ',' + str(data.loc[i, 'long'])

    response = geolocator.reverse(query)

    if cols[0] in response.raw['address']:
      data.loc[i, cols[0]] = response.raw['address'][cols[0]]

    if cols[1] in response.raw['address']:
      data.loc[i, cols[1]] = response.raw['address'][cols[1]]
  
  return data

# ---------------------------------------

def data_collect(PATH):
  # Load dataset

  data = pd.read_csv(PATH)

  # data types
  show_dtypes(data)

  return data

def data_transform(data):
  # Convert object to date
  data['date'] = pd.to_datetime(data['date'])

  # descriptive statistics
  num_attributes = data.select_dtypes(include=['int64', 'float64'])

  # central tendency - media, mediana
  media = pd.DataFrame(num_attributes.apply(np.mean, axis = 0))
  mediana = pd.DataFrame(num_attributes.apply(np.median, axis = 0))

  # dispersion - std, min, max
  std = pd.DataFrame(num_attributes.apply(np.std, axis = 0))
  min = pd.DataFrame(num_attributes.apply(np.min, axis = 0))
  max = pd.DataFrame(num_attributes.apply(np.max, axis = 0))

  df1 = pd.concat([max, min, media, mediana, std], axis = 1).reset_index()
  df1.columns = ['attributes', 'maximo', 'minimo', 'media', 'mediana', 'std']

  show_dimensions(df1)

  data['dormitory_type'] = 'NaN'

  data['dormitory_type'] = data['bedrooms'].apply(lambda x: 'studio' if x == 1 else
                                                            'apartament' if x == 2 else
                                                            'house' )

  show_dimensions(data)

  data['level'] = np.NaN

  data['level'] = data['price'].apply(lambda x: 0 if x < 321950 else
                                      1 if x >= 321950 and x < 450000 else
                                      2 if x >= 450000 and x < 645000 else 3)

  cols = ['road', 'house_number']
  df = data.head(20)
  df1 = collect_geodata(df, cols)

  show_dimensions(df1)

  return data

def data_load(data):
  houses = data[['id', 'lat', 'long', 'price', 'level']].copy()

  fig = px.scatter_mapbox(houses, 
                          lat = 'lat',
                          lon = 'long',
                          color = 'level',
                          size = 'price',
                          color_continuous_scale = px.colors.cyclical.IceFire,
                          size_max = 15,
                          zoom = 10)

  fig.update_layout(mapbox_style = 'open-street-map',
                    height = 600,
                    margin = {
                        'r': 0,
                        'l': 0,
                        'b': 0,
                        't': 0
                    })
  return None

if __name__ == '__main__':
  # ETL
  # Collect
  PATH = '/content/drive/MyDrive/Colab Notebooks/meigarom/base/kc_house_data.csv'
  data_raw = data_collect(PATH)

  # Transform
  data_processing = data_transform(data_raw)

  # Load
  data_load(data_processing)

